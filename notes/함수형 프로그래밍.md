# 함수형 프로그래밍

# 1️⃣ 순수 함수

> 순수함수란, 같은 입력이 들어오면 항상 같은 출력이 나오고, 외부 상태를 건드리지 않는 함수다.
> 

<aside>
🐱

순수함수는 예측 가능하고, 안전하고, 테스트가 쉽고, 재사용성이 높아서, 코드의 품질과 유지보수성을 크게 높여준다.

</aside>

---

## 1) 순수함수의 조건

### 조건 1)  **같은 입력 → 항상 같은 출력**

- 함수 내부에서 외부 상태나 시간, 랜덤값 등을 사용하지 않는다.
- 함수가 사용하는 모든 데이터는 **매개변수로 전달된 것만** 사용한다.

```jsx
// 비순수 함수
function getRandomPlus(x) {
  return x + Math.random();
}

// 순수함수
function add(a, b) {
  return a + b;
}
```

### 조건 2) **외부 상태를 변경하지 않는다 (side-effect 없음)**

- 전달받은 배열/객체를 직접 수정하지 않는다.
- 전역 변수 수정, 콘솔 출력, 파일 저장 등 외부 세계에 영향을 주지 않는다.
- 입력은 그대로 두고, 새로운 값을 만들어서 반환한다.

```jsx
// 비순수 함수
function pushValue(arr, x) {
  arr.push(x); // 원본 변경
  return arr;
}

// 순수 함수
function addValue(arr, x) {
  return [...arr, x]; // 새 배열 생성
}
```

---

## 2) 순수함수를 만드는 패턴

<aside>
🐱

**불변 데이터 + 인자 중심의 데이터 흐름 + map/filter/reduce**

조합이 순수 함수의 핵심이다!

</aside>

### 2-1) **원본 불변성 지키기**

- 배열 → map, filter, reduce
- 객체 → 구조 분해, 스프레드 사용한다.

```jsx
function updateUser(user, newName) {
  return { ...user, name: newName };
}
```

### 2-2) **외부 의존성 제거**

- 외부 데이터는 함수가 직접 잡아오지 말고 **매개변수로 넣어준다!**

```jsx
// 비순수 함수
let rate = 0.1;
function calc(price) {
  return price * (1 + rate);
}
// 순수 함수
function calc(price, rate) {
  return price * (1 + rate);
}

```

### 2-3) **부수효과가 필요하면 분리**

- 비순수한 부분과 순수한 부분을 나누는 구조!

```jsx
// 순수 함수
function formatUser(user) {
  return `name: ${user.name}, age: ${user.age}`;
}

// 부수효과(출력)
function print(text) {
  console.log(text);
}

```

# 2️⃣ 커링(Currying)

> **여러 인자를 받는 함수를, 인자를 하나씩 받는 함수들의 연속으로 바꾸는 기법 ⇒** f(a, b, c)를 f(a)(b)(c)로 쪼개는 방식이다!
> 
- 인자를 **부분적으로 먼저 고정**한 뒤, 나중에 나머지를 받도록 할 때
- 반복해서 쓰는 패턴을 간단하게 만들 때
- 함수 조합성을 높일 때 사용한다.
- Ex)

```jsx
예시1)
const multiply = x => y => x * y;

예시2)
function add(a) {
  return function (b) {
    return a + b;
  };
}

add(3)(4); // 7
```